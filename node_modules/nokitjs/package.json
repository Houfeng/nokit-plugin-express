{
  "name": "nokitjs",
  "displayName": "Nokit",
  "version": "1.17.9",
  "description": "A Web development framework",
  "main": "./lib/index.js",
  "bin": {
    "nokit": "./bin/cli.js"
  },
  "scripts": {
    "test": "mocha",
    "cover": "istanbul cover _mocha"
  },
  "keywords": [
    "nokit",
    "nokitjs",
    "nsp",
    "mvc",
    "rest",
    "webapi",
    "web"
  ],
  "author": {
    "name": "Houfeng",
    "email": "admin@xhou.net"
  },
  "homepage": "http://nokit.org",
  "bugs": {
    "url": "https://github.com/nokitjs/nokit/issues",
    "email": "admin@xhou.net"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nokitjs/nokit.git"
  },
  "dependencies": {
    "cheerio": "^0.19.0",
    "chokidar": "^1.4.2",
    "cmdline": "^0.0.5",
    "console.table": "^0.4.0",
    "formidable": "^1.0.17",
    "real-utils": "^0.0.1",
    "tpjs": "^3.7.1",
    "xml2js": "^0.4.15"
  },
  "devDependencies": {
    "del": "^1.2.0",
    "eslint": "^1.8.0",
    "gulp": "^3.9.0",
    "gulp-autoprefixer": "^2.3.1",
    "gulp-concat": "^2.6.0",
    "gulp-header": "^1.2.2",
    "gulp-htmlmin": "^1.2.0",
    "gulp-minify-css": "^1.2.1",
    "gulp-rename": "^1.2.2",
    "gulp-replace": "^0.5.4",
    "gulp-uglify": "^1.4.2",
    "gulp-util": "^3.0.7",
    "istanbul": "^0.4.2",
    "jshint": "^2.8.0",
    "mocha": "^2.3.4",
    "supertest": "^1.1.0"
  },
  "readme": "## 简介\nNokit 是一个简单易用的基于 Nodejs 的 Web 开发框架，默认提供了 MVC / NSP / REST 等支持，并提供对应项目模板。\nNokit 核心非常简洁，大多数功能以扩展形式存在，开发人员也可以方便的为 Nokit 添加新的扩展。\n\n[![npm version](https://badge.fury.io/js/nokitjs.svg)](http://badge.fury.io/js/nokitjs)\n[![Build Status](https://travis-ci.org/nokitjs/nokit.svg?branch=master)](https://travis-ci.org/nokitjs/nokit) \n\n## 社区\n1. wiki文档 [wiki](https://github.com/nokitjs/nokit/wiki)\n2. 问题反馈 [issues](https://github.com/nokitjs/nokit/issues)\n4. QQ群: 240603160 \n\n## 安装和更新\n\n#### 安装 nokit\n```javascript\n[sudo] npm install nokitjs [-g]\n```\n\n#### 更新 nokit\n```javascript\n[sudo] npm update nokitjs [-g]\n```\n\n## 命令行工具\n使用 “命令行工具” 时必须全局安装 nokitjs (全局安装的同时也可以在 app 中本地安装 nokitjs)\nNokit 应用只需在磁盘建立应用目录，并新建相关文件和目录即可， Nokit 提供了方便的命令行工具。\n命令行工具还提供进程管理相关功能，确保应用能够持续稳定的运行，并能在遇到故障时快速自动恢复。\n\n#### 查看版本\n```javascript\n[sudo] nokit [?]\n```\n\n#### 创建应用\n```javascript\n[sudo] nokit create [name] [mvc|nsp|rest] [folder] \n```\n以上命令会生成一个最简单的应用所需要的目录结构和配置。\n\n1. name 一般不建议省略（省略时为 nokit-app），name 将会作为应用的根目录名称\n2. type 默认为 mvc 也可以指定为 nsp 或 rest ，指定类型后将会创建对应的应用模板\n3. folder 为目标目录，省略时将默认为当前所在目录。\n \n\n#### 运行应用\n```javascript\n[sudo] nokit start [port] [root] [-env:<name>] [-cluster[:num]] [-watch[:.ext,...]] [node-opts]\n```\n1. -env 指定运行配置名称，将会根据 \"配置名称\" 加载 app.xxx.json (xxx 为指定的配置名称) 作为应用配置文件。\n2. -cluster 选项可以开启 \"单机集群模式\"，使应用有效的利用多核 CPU，也使应用更加健壮可靠，-cluster 选项可以指定进程数，如 -cluster:4 ，默认为 CPU 核数。\n3. -watch 选项开启后，在应用文件发生改变时会自动完成进程重启，默认任何文件变更都将触发重启，也可以指定文件类型，如 -watch:.js,.html,.css\n4. -public 一般用于为 html/js/css 等静态资源启动一个临时 WebServer，指定静态资源目录，静态资源目录为 root 的相对目录。\n5. --debug 为 nodejs 选项，可以开启 debug 模式，开启后可以使用 nodejs 内置调试工具调式，也可以使用 node-inspector 等工具进行调试。\n\n#### 停止应用\n```javascript\n[sudo] nokit stop [pid|all]\n```\n可以指定 pid (进程ID，可以用过 nokit list 查看)，停止指定的的应用，也可以省略停止所有应用\n\n#### 重启应用\n```javascript\n[sudo] nokit restart [pid|all]\n```\n可以指定 pid (进程ID，可以用过 nokit list 查看)，重启指定的的应用，也可以省略重启所有应用\n\n#### 查看运行中的应用\n```javascript\n[sudo] nokit list\n```\n查看所有已启动的应用\n\n#### 开机自启动\n```javascript\n[sudo] nokit autostart [on|off] [-uid:[domain\\]user [-pwd:password]] \n```\nautostart 命令目前支持 win32 和 linux 平台，此命令需要管理员权限，如 ubuntu 需要使用 sodu ，\n在 windows 平台会弹出 \"用户账户控制\" 提示框。\n-uid 和 -pwd 参数仅在 win32 平台有效，其它平台将被忽略，在不指定 -uid 、-pwd 参数时，需有用户登录到 windows \n才会自动启动 Nokit App，当指定 -uid、-pwd 时，只要启动 windows 就会自动启动 Nokit App。\n无论是登录 windows 的账户或是通过 -uid 提定的账户，需要是安装 nodejs 和 npm 时所用的账户。\n\n## 代码引用\n除了使用命令行工具，也可以在代码中引用 nokit 的方式来运行 nokit 应用，\n在代码中引用 nokit，将不能利用 nokit 的进程管理功能，这时可以直接运行，或者使用 pm2 / forever 等工具进行管理。\n```javascript\nvar nokit = require(\"nokitjs\");\nvar server = new nokit.Server({\n    root : \"应用根目录\",\n    port : 8000\n});\nserver.start();\n```\n\n无论任种方式，启动成功后，即可浏览器访问 \"http://localhost:8000\" (端口请换成具体应用的正确的端口)，\n如简单的示例 [http://jser.cc](http://jser.cc)\n\n## NSP\nNSP 全称为 Nokit Server Pages 是一种类似 asp / php 的 Web 应用开发模式，\nNSP 支持 include 引用其它页面，也支持 master 母板页技术。\n\n一般目录结构\n```javascript\n根目录\n│ app.js\n│ config.json\n├─layout\n│     date.nsp\n│     master.nsp\n├─model\n└─public\n    │  index.nsp\n    │  index.nsp.js\n    └─style\n         common.css\n```\n\nNSP 页面 (*.nsp) 基本介绍\n```html\n<!-- 输出内容 -->\n<p> <%= \"输出内容\" %> </p>\n<!-- this 指向页面处理器，无处理器页面指向默认处理器对象 -->\n<p> <%= this.context.request.formData(\"name\") %> </p>\n\n<!-- 循环 -->\n<ul> \n<% $.each(this.list,function(i,item){ %>\n    <li><%= item.name %></li>\n<% }) %>\n</ul>\n\n<!-- 分支 -->\n<% if(this.type=='a'){ %>\n<span>a</span>\n<% }else{ %>\n<span>b</span>\n<% } %>\n\n<!-- 包含 -->\n<% $.include(\"../layout/head.nsp\") %>\n\n<!-- 母板页 -->\n<html>\n...\n<div> <% $.placeHolder(\"content1\") %> </div>\n...\n<div> <% $.placeHolder(\"content2\") %> </div>\n...\n</html>\n\n<!-- 内容页 -->\n<% $.master(\"./master.nsp\") %>\n\n<% $.placeBegin(\"content1\") %>\n<span>content1</span>\n<% $.placeEnd() %>\n\n<% $.placeBegin(\"content2\") %>\n<span>content2</span>\n<% $.placeEnd() %>\n```\n\nNSP 页面处理器 (*.nsp.js) 基本介绍\n```javascript\n//定义页面处理器类型\nvar IndexPresenter = module.exports = function() {};\n\n//初始化方法，每次回发都将触发 init 方法\nIndexPresenter.prototype.init = function() {\n    var self = this;\n    /*\n    self.server //当前 server 实例\n    self.context //当前请上下文对象\n    self.request //同 context.request，请求对象\n    self.response //同 context.response 响应对象\n    self.context.request.queryData['name'] 可以获取 queryString 对应数据\n    self.context.request.formData['name'] 可以获取 post 数据\n    self.context.data(\"name\") 可以获取客户端传过来的 queryString 或 formData\n    self.context.request.cookie 获取来自客户的 cookie\n    self.context.respone.cookie 向客户端发送 cookie\n    se轩.context.session 访问 session 数据\n    */\n    self.name = 'Nokit NSP';\n    //init（初始化）完成后，需要调用 ready 方法，通知初始化完成\n    self.ready();\n};\n\n//默认方法，首次打开页面，会触发 load 方法\nIndexPresenter.prototype.load = function() {\n    var self = this;\n    //由于 nokit 为异步处理，调用 self.render() 方法向浏览器呈现页面.\n    //不要在 init 方法调用 self.render() \n    self.render();\n};\n\n//事件方法，可以绑定到页面中的 html 控件\nIndexPresenter.prototype.add = function() {\n    var self = this;\n    var val = parseInt(self.numBox.val());\n    self.numBox.val(++val);\n    self.numBox.css(\"border\",\"solid 1px red\");\n    self.render();\n};\n```\n\n页面绑定\n```html\n<!-- 绑定到处理器方法 -->\n<input type=\"button\" onclick=\"nsp.call('add')\" value='add' />\n```\n\n共享元素，将普通 DOM 元素通过 \"nsp-id\" 声明为客户端和服务端的共享元素，便可以在客户端和服务端同时操作指定元素，\n并能在回发时保持状态，类似 Asp.NET 的 WebForms，但理念、原理又非常不同，NSP 共享元素非常轻量，更简洁易用。\n```html\n<!-- 此元素可以在服务端和客户端同时访问 -->\n<input type=\"text\" value=\"hello\" nsp-id='test' />\n```\n```javascript\nIndexPresenter.prototype.add = function() {\n    var self = this;\n    //服务端提供类 jQuery 的元素操作 API (兼容部分常用 jQUery API)\n    self.test.val('你好'); \n    self.render();\n};\n```    \n\n## MVC\nNokit MVC 是一种设计简约、稳定、高效的 Web 应用开发模式。\n\n一般目录结构\n\n```javascript\n根目录\n│ app.js\n│ config.json\n├─controllers\n│    home.js\n├─models\n├─public\n│  └─style\n│       common.css\n└─views\n     date.html\n     home.html\n     master.html\n```\nviews 目录存放的是视图，视图和 NSP 的页面相似，支持 include 和 master，语法也完全相同，\n不同的是在 mvc 的视图中 this 指向的是模型，视图具有单一的责职 ，就是呈现模型中的数据。\ncontrollers 是控制器目录，单个文件为一个控制器，用来响应接受来自用户的请求，并传递给模型，\n然后，完成模型和视图的装配。\nmodels 为模型目录，nokit 对模型没有统一的要求和控制，应用的业务逻辑应在模型中完成。\n\nMVC 的控制器示例\n```javascript\n//定义控制器类型\nvar HomeController = module.exports = function() {};\n\n/*\n默认 action ，\n通常用户直接请求某一 url 会被路由到指定 controller 的默认 action\n*/\nHomeController.prototype.index = function() {\n    var self = this;\n    \n    /*\n    self.context 可以访问当前请求上下文对象\n    self.context.routeData[\"name\"] 可以获取路由数据\n    self.context.request.queryData['name'] 可以获取 queryString 对应数据\n    self.context.request.formData['name'] 可以获取 post 数据\n    self.context.data(\"name\") 可以获取客户端传过来的 queryString 或 formData\n    self.context.request.cookie 获取来自客户的 cookie\n    self.context.respone.cookie 向客户端发送 cookie\n    se轩.context.session 访问 session 数据\n    */\n    \n    //通过 self.render 方法呈现指定的视图，并进行模型绑定\n    self.render(\"home.html\", {\n        \"name\": \"Nokit MVC\"\n    });\n};\n```\n\nMVC 的 config.json 配置\n```javascript\n{\n    /*\n    配置 handler ，将指定的请求交由 MVC Handler 处理，支持正则表达式，\n    如示例，将应用的所有请求都交由 MVC 处理，\n    在找不到匹配的路由配置时，会转由 Static Handler 处理\n    */\n    \"handlers\": {\n        \"^/\": \"$./handlers/mvc\"\n    },\n    \"mvc\": {\n        /*\n        配置 MVC 相关代码文件的存放目录，指定 controller 和 view 的目录位置，\n        model 不用配置。\n        */\n        \"paths\": {\n            \"controller\": \"./controllers\",\n            \"view\": \"./views\"\n        },\n        /*\n        每一个路由至少需要指定 pattern(URL匹配模式) 和 target(目标contrller)\n        还可以通过配置 action 项指定对应的 action (controller方法)。\n        pattern 格式示例 \"/user/{userId}\" 其中 userId 是占位符变量，\n        可以在 controller 中通过 context.routeData['userId'] 获取。\n        */\n        \"routes\": {\n            \"/home\": \"./home\"\n            \"/\": \"./home\"\n        }\n    }\n}\n```\n\n\n\n## REST\nNokit 用来开发 RESTful Service 是非常方便和简单的，通过简洁的 URL 路由配置，抽象出和资源对应的请求处理程序文件即可，\n可以在处理程序中，根据需求实现 get / post / put 等 HttpMethod 即可。同时，也可以用 Nokit MVC 来开发 RESTful Service。\n\n一般目录结构\n```javascript\n根目录\n│ app.js\n│ config.json\n├─public\n│  │  index.nsp\n│  └─style\n│       common.css\n└─api\n      user.js\n```\n\nREST 的资源控制器示例\n```javascript\n//定义资源控制器类型，通常一个资源类型视为一个控制器\nfunction UserController() {};\n\n//针对 User 的 post HttpMethod 处理方法\nUserController.prototype.post = function() {\n    var self = this;\n        \n    /*\n    self.context 可以访问当前请求上下文对象\n    self.context.routeData[\"name\"] 可以获取路由数据\n    self.context.request.queryData['name'] 可以获取 queryString 对应数据\n    self.context.request.formData['name'] 可以获取 post 数据\n    self.context.data(\"name\") 可以获取客户端传过来的 queryString 或 formData\n    self.context.request.body 可以访问请求的主体对象\n    */\n    \n    var routeData = self.context.routeData;\n    self.out(\"routeData:\" + routeData[\"userId\"]);\n};\n\n//针对 User 的 get HttpMethod 处理方法\nUserController.prototype.get = function() {\n    var self = this;\n    self.out(\"routeData:\" + routeData[\"userId\"]);\n};\n\n/*\n根据需求实现对应的 httpMethod 处理方法即可\n*/\n\nmodule.exports = UserController;\n```\n\nREST 的 config.json 配置\n```javascript\n{\n    /*\n    配置 handler ，将指定的请求交由 REST Handler 处理，支持正则表达式，\n    如示例，/api/... 开头的请求，交由 REST Handler 处理\n    */\n    \"handlers\": {\n        \"^/api/\": \"$./handlers/rest\"\n    },\n    \"rest\": {\n        \"path\": \"./rest\", //指定资源控制器的存放目录\n        /*\n        每一个路由至少需要指定 pattern(URL匹配模式) 和 target(目标contrller)\n        pattern 格式示例 \"/user/{userId}\" 其中 userId 是占位符变量，\n        REST 的路由配置没有 action 配置项。\n        */\n        \"routes\": {\n            \"/api/user/{userId}\": \"./user\"\n        }\n    }\n}\n```\n",
  "readmeFilename": "README.md",
  "gitHead": "d6bdbf61b99c9ef192e1401e6a902d1b090a6329",
  "_id": "nokitjs@1.17.9",
  "_shasum": "a25f2f642fbb630955a50b377de2b729651db972",
  "_from": "nokitjs@*"
}
